\chapter{Der Prototyp}

Im Rahmen dieser Thesis  wurde auch ein Prototyp für die Erkennung von Verkehrsmitteln aus GPS-Daten entwickelt. In Abstimmung mit den Zielen, dass es im Prinzip jeder Person (mit einem Gerät das GPS-Tracks aufzeichnen kann und Zugang zu einem Computer mit Internetzug) möglich sein soll ihre eigenen Daten mit diesem Prototypen analysieren zu lassen wurde eine Webapplikation entwickelt. Diese Applikation verwendet serverseitig das PHP-Framework Symfony als Grundlage und stellt eine REST-Schnittstelle zur Kommunikation zu Verfügung.

Der Prototyp bietet neben dem Filtern, Segmentieren und Analysieren der GPS-Daten auch eine Visualisierung der analysierten Daten an. Dies bedeutet, dass das Resultat der Verarbeitung auf einer Karte dargestellt wird. Zusätzlich zu der Darstellung der Karte wird dem Benutzer durch auch die Möglichkeit geboten, die Resultate des Prozesses zu bearbeiten und somit gegebenenfalls das Verkehrsmittel zu korrigieren. 

Sowohl der vom System bestimmte als auch der vom Benutzer  korrigierte Verkehrsmitteltyp wird in der Datenbank abgelegt um Aussagen über die Genauigkeit beider Verfahren (mit und ohne GIS-Daten) treffen zu können. Dies Auswertung werden wiederum durch verschiedene Diagramme und Statistiken visualisiert.
\clearpage

\section{Aufbau und Architektur}
Der Kern der Webapplikation ist in einer Pipes-and-Filter Architektur aufgebaut. Diese Architektur bietet sich an wenn man einen Datenstrom verarbeiten will. Dabei werden die einzelnen Schritte der Verarbeitung in sogenannte Filter unterteilt und diese werden mit Kanälen (Pipes) verbunden. Die Daten fließen somit in einen Filter, werden dort bearbeitet und schlussendlich über die verbunden Kanäle zu einem oder mehreren nachfolgenden Filtern weitergeleitet. Am Ende einer solchen Kette steht eine Senke (sink) in welcher die Daten schlussendlich abgelegt werden (z.B. eine Datei). Durch dieses Architekturmuster wird eine Codegliederung in einzelnen Komponenten/Arbeitsschritte in gewisser Weise bereits vorgegeben. Aber es ergeben sich auch andere Vorteile wie z.B. Flexibilität bezüglich der Datenquelle, Austauschbarkeit oder auch den Endergebnissen. Weiters müssen bei diesem Ansatz auch keine Zwischendateien o.Ä. geschrieben werden. \cite{buschmann_pipes_1998} 

So werden im Falle dieses Prototyps die Trainingsdaten in eine Datei geschrieben oder bei einer Anfrage über die Webapplikation werden die diese in die Datenbank geschrieben. Hierbei unterscheiden sich nicht nur die Persistierungsarten sondern auch die Darstellung der Daten selbst da in die Datei im CSV-Format geschrieben wird.

\subsection{Pipes und Filter-Anordnung für Trainingsdaten}
Die Anordnung der einzelnen Filter für die Verarbeitung der GPS-Daten ist im Falle der Trainingsdaten in Abbildung \imgref{pipesAndFilterTraining} ersichtlich. Hierbei wird das Verzeichnis mit den Trainingsdaten definiert und dem ersten Filter (Filereader) werden nach und nach die einzelnen Dateien übergeben. Nachdem die Daten den Trackpoint-, und Tracksegmentfilter (grün ohne GIS-Daten, orange mit GIS-Daten) durchlaufen haben werden sie schließlich vom letzten Filter (FileWriter) in eine Datei geschrieben.

\img{1}{document/graphics/pipes_and_filter_diagram_training.png}{Pipes- und Filter- Struktur für Trainingsdaten}{pipesAndFilterTraining}

\subsubsection{FileReader-Filter}
Der FileReader-Filter liest die Datei mit dem angegeben Dateinamen als XML-Datei ein, sucht sich alle Segmente (trkseg) aus dieser Datei und gibt diese schließlich an den nächsten Filter weiter. Als eingelesene Datei erwartet sich dieser Filter eine XML-Datei im GPX-Format.

\subsubsection{Trackpoint-Filter}
Der Trackpoint-Filter ist nicht nur ein Filter im Sinne des Architekturmusters sondern auch im Sinne seiner Aufgabe. Er versucht all jene Trackpunkte (trkpt) herauszufiltern die nicht den konfigurierten Grenzwerten entsprechen. Dies bedeutet, dass all jene Trackpunkte gefiltert werden bei welchen der Zeitabstand, die Geschwindigkeit oder die Änderung im Bereich der Höhenmeter über oder unter den Grenzwerten liegen. Dadurch werden die einzelnen Segmente von den gröbsten fehlerhaften Ausreißern bereinigt bevor sie an den nächsten Filter weitergeben werden.

\subsubsection{Tracksegment-Filter}
\label{tracksegmentFilter}
Der Tracksegment-Filter ist einer der wichtigsten Filter in dem Verarbeitungsprozess. Er berechnet für jedes Segment die für die weitere Verarbeitung benötigten Zusatzwerte. Dies bedeutet, dass er die mittlere und maximale Beschleunigung, die mittlere und maximale Geschwindigkeit sowie die Stopprate berechnet. Weitere Informationen über die gewählten Zusatzwerte sowie die Auswahl selbst sind im Abschnitt \nameref{schlussfolgerungsvariablen} zu finden.  Im Falle der Trainingsdaten ergänzt er die Segmentdaten noch mit den in den Trainingsdaten definierten Verkehrsmitteltyp.

\subsubsection{FileWriter-Filter}
Der FileWriter-Filter übernimmt das Schreiben der übergebenen Daten in eine Datei. Hierbei werden die vom Tracksegment-Filter übergeben Segment in einer Datei im CSV-Format abgelegt, welche in weiterer Folge im Rapidminer verwendet wird.

\subsection{Pipes und Filter-Anordnung für die Webapplikation}
Die Anordnung der einzelnen Filter für die Verarbeitung der GPS-Daten die über die Webapplikation verarbeitet werden sollen ist in Abbildung \imgref{pipesAndFilter} ersichtlich. Der Ablauf ist hierbei ähnlich wie jener bei den Trainingsdaten, und es wird wiederum zwischen den zwei Modi mit GIS-Daten (orange) oder ohne GIS-Daten (grün) unterschieden. Ausgehend vom FileReader- und Trackpoint-Filter kommen die Daten in den Segmentation-Filter. Von dort kommen sie je nach Analyse-Art in dem Tracksegment-Filter oder in dem GISTracksegment-Filter. Das Ergebnis dieser Filter kommt danach in den TravelModel- bzw. GISTravelModeFilter wo die eigentlichen Verkehrsmittel bestimmt werden. Anschließend werden die Ergebnisse dem Postprocess-Filter übergeben welche die bestimmten Verkehrsmitteln ein letztes mal überprüft um schlussendlich an den Database-Filter übergeben zu werden, welcher die Ergebnisse für die Datenbank aufbereitet in dieser ablegt.

\img{0.85}{document/graphics/pipes_and_filter_diagram.png}{Pipes- und Filter- Struktur der Webapplikation}{pipesAndFilter}

\subsubsection{Segmentation-Filter}
Der Segementation-Filter teilt die Tracksegmente der einzelnen Tracks in Teile, welche mit hoher Wahrscheinlichkeit nur mit einem Verkehrsmittel bewältigt wurden. Dazu verwendet dieser ermittelte Geschwindigkeits- sowie Beschleunigungswerte. Dieser Vorgang stützt sich auf die Ergebnisse aus den Publikationen von Zheng \cite{zheng_understanding_2010} und Biljecki \cite{biljecki_transportation_2013}. Der genaue Ablauf dieses Prozesses ist im Abschnitt \nameref{segmentierung} beschrieben.

\subsubsection{GISTracksegment-Filter}
\label{gisTracksegmentFilter}
Der GISTracksegment-Filter macht im wesentlichen das Selbe wie der normale Tracksegment-Filter, allerdings berechnet er zusätzlich zu den Geschwindigkeit und Beschleunigungswerten noch die Abstände zu den verschiedenen Infrastrukturen wie Busstationen, Schienen und Autobahnen. Diese Werte werden im weiteren Verlauf benötigt um beim GISTravelMode-Filter eine genauere Bestimmung zu ermöglichen.

\subsubsection{TravelMode-Filter und GISTravelMode-Filter}
In diesen Filtern wird der eigentliche Verkehrsmitteltyp anhand der berechneten Werte bestimmt. Dies geschieht in beiden Fällen mit Hilfe des Entscheidungsbaumes (siehe Abschnitt \nameref{entscheidungsbaum} und \nameref{entscheidungsbaumGIS}) welcher mit Hilfe der jeweiligen Trainingsdaten generiert worden ist.

\subsubsection{Postprocessing-Filter}
Bei diesem Filter geht es darum, dass wenn alle Verkehrsmittel aller Segmente eines Tracks bestimmt worden sind, die Wahrscheinlichkeit der Wechsel nochmals überprüft wird. Diese letzte Überprüfung der Resultate der Entscheidungsbäume basiert auf Zheng \cite{zheng_understanding_2010} und soll verhindern, dass sehr unwahrscheinliche Verkehrsmittelwechsels wie zum Beispiel ``Auto->zu Fuß->Auto->zu Fuß->Auto`` entstehen. Zheng trifft diese letzte Entscheidung über den Verkehrsmitteltyp in weiterer Folge aber nicht nur auf Grund von Wahrscheinlichkeiten sondern auch durch jenen Graph den er während des Analysierens der Trainingsdaten aufgebaut hat. In diesem Postprocessing-Filter wurde der Wahrscheinlichkeiten-basierte Ansatz implementiert, welcher in der Evaluierung von Zheng einen Anstieg der korrekten Erkennungsrate um 2\% zur Folge hatte.

\subsubsection{Database-Filter}
Da das Ablegen der ermittelten Ergebnisse in der Datenbank  nur eine Variante (neben z.B. dem Ablegen  in einer Datei) von vielen ist kümmert sich dieser Filter darum, dass die übergebenen Daten für die Datenbank auf bereitet werden und schlussendlich persistiert werden können.

\section{UI und Funktionalitäten?}
\todo{ui und funktionalitäten für den benutzer}