\section{Klassifizierung der Verkehrsmittel}
Die Klassifizierung der Segmente bzw. das Bestimmen des Verkehrsmittels für ein Segment basiert bei beiden Analysearten (mit und ohne GIS-Daten) auf Entscheidungsbäumen. Wie bereits in Abbildung \imgref{decisiontree} und in Abbildung \imgref{decisiontree-gis} ersichtlich und im Abschnitt ``\ref{schlussfolgerungsvariablen} \nameref{schlussfolgerungsvariablen}`` genau beschrieben, verwendet der Entscheidungsbaum ohne GIS-Daten ausschließlich Geschwindigkeits- und Beschleunigungswerte sowie die Stopprate als Indikatoren. Der Entscheidungsbaum mit GIS-Daten fügt diesen aber noch einen Wert für die Nahe zu verschieden Infrastrukturen hinzu.

\subsection{Erstellen der Entscheidungsbäume}
\label{entscheidungsbaumGenerierungPHP}
Wie bereits im Abschnitt ``\ref{entscheidungsbaumAlsSchlussfolgerungsmodell} \nameref{entscheidungsbaumAlsSchlussfolgerungsmodell}`` beschrieben, konnte in der freien Version von Rapidminer der generierte Entscheidungsbaum als Bild oder Text exportiert werden. Um jedoch bei dem Erstellen des Entscheidungsbaums möglichst flexibel zu sein (z.B. erweitern der Trainingsdaten) wurde ein Parser für die textuelle Darstellung des Entscheidungsbaums implementiert. 

Ein Ausschnitt des Entscheidungsbaums als Text ist in Listing \coderef{entscheidungsbaumText} zu sehen. Dabei stellt jede Zeile mindestens einen Knoten im Baum dar. Eine Zeile kann mit Indikatoren für die Tiefe des Knotens im Baum beginnen. Dabei steht jedes ``|`` für eine Ebene tiefer im Baum. Jene zwei Zeilen am Beginn ohne Tiefenangabe bilden somit den Wurzelknoten, da sie über keine Tiefenangabe verfügen. Außerdem gibt es jeden Knoten, der kein Blatt ist, zwei Mal in dieser Darstellung. Diese beiden Knoten unterscheiden sich dabei nur durch ihren Vergleichsoperator, denn dieser ist genau das Gegenteil des Anderen. Dadurch können beide Fälle einer Bedingung, abgebildet werden.

Jede Zeile besteht aus dem Namen der Entscheidungsvariable, einem Vergleichsoperator und einem Wert. Hat ein Knoten nur mehr einen Kind-Knoten mit dem Resultat so folgt hinter dem Wert das Resultat. Das Resultat besteht dabei aus dem bestimmten Verkehrsmittel und einer Übersicht über die Vorkommnisse aller Verkehrsmittel für die getroffenen Entscheidungen aus den Trainingsdaten.

Alle Kind-Knoten sind jeweils dem letzten Knoten auf dem vorherigen Level zuzuordnen.

\begin{code}[]{Entscheidungsbaum in Textform}{entscheidungsbaumText}
meanvelocity > 20.830: train {bike=0, walk=0, car=0, bus=0, train=5}
meanvelocity <= 20.830
|   meanvelocity > 2.041
|   |   meanvelocity > 7.837
|   |   |   meanvelocity > 8.772: car {bike=0, walk=0, car=46, bus=1, train=2}
|   |   |   meanvelocity <= 8.772
|   |   |   |   meanacceleration > 2.728: bus {bike=0, walk=0, car=0, bus=2, train=0}
|   |   |   |   meanacceleration <= 2.728: car {bike=0, walk=0, car=3, bus=0, train=0}
...
\end{code}

\textbf{Parsen und Cachen der Entscheidungsbäume} \\
\label{parsenCachenEntscheidungsbaum}
Die von Rapidminer gelieferten Entscheidungsbäume wurden im Prototypen als Teil der Konfiguration hinterlegt. Damit die Entscheidungsbäume nicht für jeden Anfrage geparst und erstellt werden müssen, bietet das Framework Symfony die Möglichkeit, die aus Konfigurationsdateien entstandenen Resultate zu cachen. Dies bedeutet in diesem Fall, dass die Entscheidungsbäume eingelesen sowie geparst werden und danach mit Hilfe des Resultats eine PHP-Datei erstellt wird. Darin wird die Initialisierung des Entscheidungsbaums als Code abgelegt (siehe Listing \coderef{entscheidungsbaumPHP}). Dadurch muss der Entscheidungsbaum nicht jedes mal neu geparst sondern nur ein Objekt mit genau diesem Baum instanziiert werden. 

\begin{code}[PHP]{Ausschnitt des generierten Entscheidungsbaums als PHP-Klasse}{entscheidungsbaumPHP}
...
class BasicDecisionTree implements DecisionTreeInterface
{
    protected $tree;

    function __construct()
    {
        $node0 = new Node();
        $node0->setDecision(new Decision('meanvelocity', '>', 20.83));
        $node1 = new Node();
        $node1->setResult(new Result(0,0,0,0,5));
        ...
        $node0->setRight($node2);
        $node1->setParent($node1);
        $node2->setParent($node0);
        $node2->setLeft($node3);
        ...
\end{code}

Damit dieser Vorgang nur gemacht wird, wenn sich die Datei mit dem Entscheidungsbaum in Textform verändert, merkt Symfony sich das Änderungsdatum und entscheidet basierend darauf, ob die PHP-Datei neu generiert werden muss.

\subsection{Verwendung der Entscheidungsbäume}
\label{entscheidungsbaum_verwendung}
Die jeweiligen Entscheidungsbäume werden basierend auf der Analysemethode im TravelMode-Filter verwendet. Dabei wird für jedes Segment der Entscheidungsbaum traversiert und das Resultat bei dem jeweiligen Segment hinterlegt. Schlussendlich hat jedes Segment einen Verkehrsmitteltyp zugeordnet bekommen und wird zur Nachbearbeitung weitergegeben.

\subsection{Nachbearbeitung}
\label{nachbearbeitung}
Die Nachbearbeitung der Segmente mit dem bestimmten Verkehrsmittel wurde sowohl von Zheng \cite{zheng_understanding_2010} als auch Biljecki \cite{biljecki_transportation_2013} vorgeschlagen bzw. beschrieben. Dabei geht es darum die klassifizierten Segment auch in einem Kontext zu sehen. So kann laut Zheng \cite{zheng_understanding_2010} zum Beispiel nicht ein ``Auto``-Segment auf ein ``Bus``-Segment folgen, ohne dass sich zwischen ihnen ein Segment zu Fuß befindet (auch wenn dieses sehr kurz ist). Durch diese Aussage können sich Verkehrsmittelwechsel die zum Beispiel aufgrund der Testdaten entstanden aber nicht plausibel sind, beseitigen lassen. Dies bedeutet, dass das vorherige korrekt identifizierte Segment (im Sinne des Kontexts) als Ausgang für das nächste Segment verwendet wird und dabei auch der Verkehrsmitteltyp des vorherigen Segments übernommen wird. 

Ein Beispiel dafür ist in Abbildung \imgref{nopostprocessing-vs-postprocessing} zu sehen. Links sieht man dabei den analysierten Track ohne Nachbearbeitung und rechts mit Nachbearbeitung. Die Abfolge der Verkehrsmittel links ist dabei Bus->Auto->Fahrrad->Auto->Fahrrad->Bus->Auto was schlicht nicht möglich ist und aufgrund der Trainingsdaten und den fehlenden Kontext entstanden ist. Nach der Nachbearbeitung ist das korrekte Resultat eine durchgängige Busfahrt. 

\img{1}{document/graphics/postprocessing.png}{Kein Nachbearbeiten vs. Nachbearbeiten}{nopostprocessing-vs-postprocessing}

Eine weitere Aufgabe die das Nachbearbeiten übernimmt und aufgrund der vielen unterschiedlichen Fahrrad-Trainingsdaten entstanden ist, ist jene vereinzelte Fahrradsegment herauszufilter. In einigen Fällen konnte es vorkommen, dass einzelne Segmente als Fahrrad-Segment identifiziert worden sind, diese aber für sich alleine standen wie z.B. zu Fuß->Fahrrad->Bus->Bus->Bus. Aus diesem Grund wurde das Nachbearbeiten dahingehend erweitert, dass einzelne Fahrradsegmente herausgefiltert werden bzw. der Typ des Segments mit dem des vorherigen oder nächsten Segments abgestimmt wird.
\clearpage

